\documentclass[10pt,titlepage,twoside,a4paper]{report}
\usepackage[margin=1in,a4paper]{geometry}
\usepackage[italian]{babel}
\usepackage{lmodern}
\usepackage[latin1]{inputenc}
\usepackage{graphics,url,amsfonts,epsfig,hyperref,float,listings}
\usepackage{caption}
\usepackage{minted}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{setspace}
    \doublespacing
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[listing]{justification=centering,format=listing,labelfont=white,textfont=white}
\newenvironment{code}{\singlespacing\captionsetup{type=listing}}{}

% Manually change the language otherwise it does not work.
\renewcommand{\listingscaption}{Listato}
\renewcommand{\listoflistingscaption}{Elenco dei listati}

%%%%%% Enable to debug
%\usepackage{showframe}

\definecolor{bg}{rgb}{0.95,0.95,0.95}

% Global minted options.
\usemintedstyle{tango}
% Verbatim imput
\newminted{text}{fontsize=\footnotesize,frame=single,framesep=10pt,breaklines,bgcolor=bg,linenos=true}
\newminted{prolog}{fontsize=\footnotesize,frame=single,framesep=10pt,breaklines,bgcolor=bg,linenos=true}
\newminted{r}{fontsize=\footnotesize,frame=single,framesep=10pt,breaklines,bgcolor=bg,linenos=true}
% Inputfiles
\newmintedfile[bashcodefile]{bash}{fontsize=\footnotesize,frame=single,framesep=10pt,breaklines,bgcolor=bg,linenos=true}
\newmintedfile[prologcodefile]{prolog}{fontsize=\footnotesize,frame=single,framesep=10pt,breaklines,bgcolor=bg,linenos=true}


%%%%
%%%%
%%%%
%%%%


\title{Integrazione di una applicazione web con strumenti per la statistica}
%\title{\textsc{Integrazione di una applicazione web con strumenti per la statistica}}
\author{Franco Masotti}

\begin{document}
\pagenumbering{roman}

\maketitle
\newpage
\tableofcontents
\newpage
\listoffigures
\newpage
\listoftables
\newpage
\listoflistings
\cleardoublepage

\pagenumbering{arabic}

\chapter{Indice provvisorio} \label{Indice provvisorio}
L'oggetto di questa tesi \'e spiegare come \'e avvenuta l'integrazione di 
componenti per la statistica per l'applicazione "SWISH" in particolare
per quel che riguarda
\begin{itemize}
    \item l'interfacciamento con R,
    \item l'adattamento dell'installazione per R,
    \item ed infine la creazione di grafici per R con l'aggiunta di esempi.
\end{itemize}

Possibili capitoli:
\begin{enumerate}
    \item Introduzione (da fare alla fine)
    \item Scopo???
    \item Ambiente di lavoro
    \begin{enumerate}
        \item R
        \item SWI Prolog and SWISH
        \item QEMU
        \item Distribuzioni
            \begin{enumerate}
                \item Antergos + Parabola
                \item Debian + Trisquel
                \item speigare perch\'e 
                      l'utilizzo di distro FSDG e non mainstrewam (free sw + 
                      super updated (Parabola)).
            \end{enumerate}
        \item Perch\'e in macchina virtuale piuttosto che direttamente sul PC
        \item Mio script qvm semplifica l'uso di qemu attraverso l'utilizzo di 
              backup del VHD, etc...
    \end{enumerate}
    \item Pacchetti Arch Linux e derivate + Debian e derivate
    \begin{enumerate}
        \item Risolve il problema di "Adattare l'installazione per R" 
              (rserve-sandbox-docker) oltre che fornire un modo semplice per 
              installare l'interfaccia web (swish-cplint).
        \item Scrittura del pacchetto swish da swish-cplint
        \item Linee guida da apllicare a tutte le distribuzioni: perch\'e e 
              come funzionano.
        \item pacchetti Debian e Ubuntu-like (Trisquel). Spiegare perch\'e \'e 
              pi\'u fifficile fare qualcosa per questi sistemi (pacchetti 
              obsoleti).
        \item pacchetti bin: nel caso non si riesca a compilare/scariare 
              qualcosa.
    \end{enumerate}
    \item Libreria cplint\_r
    \begin{enumerate}
        \item Libreria prolog che si interfaccia con R e che consente il plot 
              dei gafici.
        \item Perch\'e ggplot2 (grammar of graphs)
        \item Metodo della libreria: Adattare i predicati della libreria cplint 
              ed adattarli alla nuova situazione, mantenendo i necessari e 
              creandone di nuovi (ovviamente solo quando necessario)
        \item Metodo degli esempi: copia file .pl in \_R.pl, adattamento per 
              usare la libreria, confronto con grafici originali in c3js
        \item <cplint\_r include cplint direttamente perche' in cplint c'\'e la 
              parte dei conti matematici (ancora valida) mentre la parte di plot 
              \'e presente in ogni esempio, quindi i predicati di cplint si 
              possono chiamare direttamente facendo poche modifiche.
        \item Cose degne di nota: Come funziona il passaggio di valori da 
              prolog ad R (e viceversa): speigare gli helpers che ho scritto. 
    \end{enumerate}
    \item Esempi prolog slegati da cplint\_r
    \begin{enumerate}
        \item Quali (gpr\_R.pl esempio pi\'u difficile da trasformare).
        \item Perch\'e: es: perch\'e non si poteva usare cplint\_r
        \item Come
    \end{enumerate}
    \item Documentazione
    \begin{enumerate}
        \item Perch\'e in texinfo: perch\'e permette di creare output in vari 
              formati automaticamente.
    \end{enumerate}
    \item Conclusione
    \begin{enumerate}
        \item Imparato rudimenti programmazione logica
        \item Imparato a costruire strutture semplici per ottenere risultati 
              "complessi" (Makefile dei pacchetti, stessa cplint\_r).
    \end{enumerate}
\end{enumerate}


%%%%
%%%%
%%%%
%%%%


\chapter{Descrizione dei principali componenti software} \label{ch:descrizione 
dei-principali-componenti-software}
Per migliorare l'iterfaccia web in questione \'e necessario spiegare il ruolo 
dei pi\'u importanti software utilizzati.

\emph{SWI Prolog} \'e un interprete per la programmazione 
logica\cite{swiprolog}, come suggersice il nome\cite{prolog}

La piattaforma \emph{SWISH}\cite{SWISH} viene usata per la programmazione 
logica attraverso un qualunque web browser dotato di Javascript. Questa 
\'e collegata direttamente all'interprete SWI Prolog ed \'e accessibile da 
shell con il comando \texttt{swipl}.

\emph{Cplint on SWISH} \'e una versione modificata di SWISH che include la 
libreria \emph{cplint}, la quale permette di formulare inferenze e 
compiere processi di apprendimento\cite{cplint}.

\emph{R} \'e un ambiente software dedicato alla statistica e 
alla rappresentazione grafica di dati\cite{r}.

\emph{ggplot2} \'e un pacchetto R che permette di fare plot usando la 
cosiddetta \emph{grammatica dei grafici}, cio\'e la divisione per contesti dei 
vari aspetti di un grafico (check this and cite...)

\emph{Docker} \'e un software... che permette di eseguire 
\emph{containter} in modo isolato. ??? I container sono degli ambienti che 
possono essere eseguiti su qualunque macchina in modo indipendente dalla 
configurazione del sistema operativo in modo che il software 
funzioni sempre allo stesso modo???\cite{docker}


%%%%
%%%%
%%%%
%%%%


\chapter{Preparazione}
Per completare tutto il lavoro e testare le modifiche sui programmi man 
mano, \'e stato necessario installare l'intera piattaforma sul computer. 
Questo \'e stato possibile attraverso l'utilizzo di macchine virtuali 
per ragioni di comodit\'a.

\section{Macchine virtuali}
Per agevolare l'installazione ed il mantenimento della piattaforma web su una 
istanza locale si sono utilizzate macchine virtuali con immagini di 
distribuzioni GNU/Linux diverse quali: Antergos, Parabola GNU/Linux-libre, 
Debian e Trisquel.

\subsection{Qemu Virtual Machine}
Utilizzando il programma \emph{QEMU}\cite{qemu} si \'e potuto scrivere uno 
programma per 
shell, \emph{qvm}, in modo da gestire facilmente tutti i casi d'uso che si 
sono presentati\cite{qvm}. Questo si \'e rivelato molto utile per esempio per 
gestire i backup dei dischi rigidi virtuali. Infatti per testare nuovi 
pacchetti e programmi \'e consigliabile partire sempre da un sistema pulito
per evitare che precedenti installazioni possano alterare il funzionamento.
Con qvm sono infatti sufficienti un paio di comandi per ripristinare il 
backup e corregere l'errore.

Lo script d\'a anche la possibilit\'a di condividere file fra la macchina host 
e guest attraverso una semplice directory.

Poich\'e l'interfaccia web di SWISH \'e accessibile attraverso un \emph{port} 
ben definito (di default \emph{3050}), si \'e fatto in modo che tale port 
fosse accessibile dalla macchina host con il port \emph{5555}. Oltre a questo 
\'e anche possibile l'accesso attraverso attraverso \emph{Secure 
Shell} (\emph{SSH}). Mettendo insieme queste due caratteristiche non \'e 
neccessario avviare l'interfaccia grafica.

Di seguito \'e riportata l'opzione di aiuto, mentre lo script si trova 
nell'appendice~\ref{app:qvm}.

\begin{code}
    \caption{Pagina di aiuto di qvm}
    \begin{textcode*}{}
Usage: qvm [OPTION]
Trivial management of 64 bit virtual machines with qemu.

Options:
    -a, --attach                connect via SSH
    -b, --backup                backup vhd
    -c, --create                create new vhd
    -d, --delete                delete vhd backup
        --delete-orig           delete original vhd
    -h, --help                  print this help
    -i, --install               install img on vhd
    -n, --run-nox               run vm without opening a graphical window
                                (useful for background jobs like SSH)
        --run-nox-orig          run-orig and run-nox combined
    -s, --mkdir-shared          create shared directory
    -x, --run                   run vm
        --run-orig              run from original vhd


Only a single option is accepted.
By default, the backup vhd is run.

CC0
Written in 2016 by Franco Masotti/frnmst <franco.masotti@student.unife.it>
    \end{textcode*}
\end{code}

\subsection{Installazione e avvio di una nuova macchina virtuale con qvm}
La prima cosa da compiere \'e quella di ottenere l'immagine \emph{ISO} della 
distribuzione da installare.

Successivamente si deve configurare il file \texttt{configvmrc} inserendo il 
nome del file ISO.

Poi \'e necessario eseguire \mint{bash}|$ ./qvm -c| per creare un nuovo 
disco rigido virtuale, poi \mint{bash}|$ ./qvm -i| per l'installazione.

Una volta terminata l'installazione si pu\'o aggiungere SSH sulla macchina 
guest oltre che aggiungere la seguente riga nel file \texttt{/etc/fstab} della 
macchina virtuale in modo da aggiungere la directory condivisa:

\begin{code}
   \caption{Comando fstab}
    \begin{textcode*}{}
host_share /home/<shared_directory_path> 9p noauto,x-systemd.automount,trans=virtio,version=9p2000.L 0 0
    \end{textcode*}
\end{code}

Ora si pu\'o creare un backup dell'hard disk virtuale con \mint{bash}|$ ./qvm 
-b| che nel caso fosse necessario rimuoverlo baster\'a fare \mint{bash}|$ ./qvm 
-d|

Successivamente si avvia la macchina virtuale con \mint{bash}|$ ./qvm -x| 
oppure con \mint{bash}|$./qvm -n| rispettivamente a seconda che si utilizzi o 
non si utilizzi l'interfaccia grafica sulla macchina guest.

Infine, per collegarsi via SSH: \mint{bash}|$ ./qvm -a|

%%%%
%%%%
%%%%
%%%%


\chapter{Gestire R da SWISH}
\section{Funzionamento interno}
Il supporto per R all'inteno di SWISH \'e ancora sperimentale. Di solito, 
infatti, la parte computazionale \'e affidata all'interprete Prolog, mentre la 
parte grafica viene gestita dalla libreria c3js.

Grazie ad alcuni programmi \'e per\'o possibile utilizzare i comandi 
disponibili dell'interprete R direttamente da SWISH. Questo comporta due 
vantaggi: una maggiore velocit\'a e precisione computazionale .. cite .. e la 
possibilit\'a di usare i sistemi di plot di R, come per esempio ggplot2 ...
che si rivelano pi\'u precisi ... cite ... ...

Nel caso presente tutte le chiamate fatte da Prolog a R sono gestite da un 
socket UNIX creato dal programma \emph{Rserve}\cite{rserve}. Questo \'e stato 
configurato opportunamente per quanto riguarda la sicurezza in quanto viene 
eseguito all'interno di Docker e senza che venga esposta una connessione di 
rete come si vede nell'appendice~\ref{app:rserve-sandbox}.

... A simple picure/schematic explaining this would be nice here ...

Grazie ad una libreria di SWI Prolog chiamata 
\emph{rserve\_client}\cite{rserveclient} 
\'e possibile usare direttamente comandi di R facendo minime modifiche 
rispetto allo stesso codice usato nell'interprete R.

... ...

\section{Scambiare i dati fra R e Prolog}
Esistono due modalit\'a per usare i comandi di R all'interno di SWI Prolog:
\begin{itemize}
    \item come Prolog term, usando l'operatore \texttt{<-} seguito dal comando R,
    \item oppure con una notazione chiamata \emph{quasi-quotation}
\end{itemize}
SWISH contiene un esempio per entambi i casi\cite{rprolognotations}:

\begin{code}
    \caption{Esempi notazioni R in SWI Prolog}
    \begin{prologcode*}{}
<- qplot(mpg, data=mtcars, geom="density", fill=gear, alpha='I'(0.5), main="Distribution of Gas Milage", xlab="Miles Per Gallon", ylab="Density").

<- {|r||qplot(mpg, data=mtcars, geom="density", fill=gear, alpha=I(.5), main="Distribution of Gas Milage", xlab="Miles Per Gallon", ylab="Density")|}.
    \end{prologcode*}
\end{code}

Come si vede nel primo caso \'e necessario fare qualche piccola modifica 
rispetto all'originale R. Nel secondo caso invece \'e possibile gestire alcuni 
casi particolari che genererebbero errori oppure che non sarebbe possibile 
possibile trasformare nel primo caso. Per esempio non sarebbe possibile 
trasformare il seguente comando con la notazione abbreviata:

\begin{code}
    \caption{Esempio di quasi quotation}
    \begin{rcode*}{}
{|r||xbreakS <- if(max(df$probabilities) > scalingthresholD) element_blank() else scale_y_continuous(breaks=seq(0,max(df$probabilities),1))|},
    \end{rcode*}
\end{code}

Questo \'e vero perch\'e ogni comando R inviato attraverso questo sistema viene 
eseguito in un ambiente proprio. Le variabili devono 
essere salvate in Prolog se devono essere usate successivamente... check 
this and explain...

\section{I data frame}
Alcune funzioni disponibili nella libreria \emph{r\_swish} permettono il 
passaggio di valori tra Prolog ed R attraverso i \emph{data frame}. Quesi sono 
strutture fornite da R che permettono di organizzare i dati sotto forma 
tabulare che si rivela anche efficiente per R stesso. In questo modo \'e 
possibile accedere ai valori di ciascuna colonna del data frame in questione.


%%%%
%%%%
%%%%
%%%%


\chapter{La libreria cplint\_r} \label{la-libreria-cplint-r}
\emph{cplint\_r} \'e una libreria per SWI Prolog che fornisce un'interfaccia 
fra l'interprete Prolog ed R, in modo da poter graficare i risultati generati 
dalla libreria cplint. Questo significa che cplint\_r si occupa esclusivamente 
del disegno dei grafici.

...Esistono tuttavia alcune differenze, come ad esempio che una 
parte del lavoro viene fatto gestire da R automaticamente ... esempio bins 
histograms ... ... code here ...
...

La struttura di cplint\_r \'e composta da tre diversi tipi di predicati:
\begin{enumerate}
    \item I predicati che espongono un'interfaccia. Questi chiamano alcuni 
          predicati di cplint per quanto riguarda il calcolo dei risultati.
    \item Le funzioni grafiche invece per prima cosa trasformano i dati in 
          input in data frame leggibili da R, poi viene effettuato il disegno 
          dei grafici.
    \item Infine, sono stati scritti alcuni predicati che aiutano a gestire le 
          liste di valori generate dalle funzioni di cplint. Queste liste 
          vengono poi trasformate in \emph{data frame} in modo che possano 
          essere utilizzati da R.
\end{enumerate}

cplint\_r contiene dei semplici test post installazione per verificare che la 
libreria funzioni correttamente.


%%%%
%%%%
%%%%
%%%%


\chapter{Trasformazione degli esempi da c3js ad R} \label{ch:trasformazione-
degli-esempi-da-c3js-ad-r}
... Per prima cosa sono state fatte delle prove per vedere come fuzionava 
prolog ed R ...

Dopo aver definito le basi della libreria cplint\_r si \'e provveduto a 
trasformare qualche esempio pi\'u semplice da c3js ad R. Infatti si \'e 
dovuto cambiare una minima parte del codici, tranne in casi particolari, per la 
trasformazione.

Alcuni casi particolari non hanno permesso di sfruttare completamente la 
libreria cplint\_r in quanto si sono dovuti creare predicati specifici per 
risolvere il problema, che non sarebbero utili all'interno di una libreria. 
... Si veda gpr\_R kalman\_filter\_R seven\_scientists\_R, etc... ...


... La parte grafica si \'e spostata dagli esempi a cplint\_r ...

%%%%
%%%%
%%%%
%%%%


\chapter{Pacchetti per le varie distribuzioni} 
\label{ch:pacchetti-per-le-varie-distribuzioni}
Un pacchetto software \'e una raccolta di istruzioni che permettono di 
installare un programma in modo uniforme rispetto ad altri pacchetti, grazie ad 
un altro programma chiamato \emph{gestore di pacchetti}.

Questi gestori hanno contribuito al successo delle distribuzioni GNU/Linux (ed 
altre, BSD, etc...) perch\'e consentono a chiunque di installare un programma 
senza aver conoscenza di metodi di compilazione software oltre a rendere 
l'installazione pi\'u veloce e meno prona a generare errori.

Per affrontare il problema dell'installazione di tutti i componenti di cui si 
\'e parlato fino ad ora, si \'e resa quindi necessaria la creazione di vari 
pacchetti software per:
\begin{itemize}
    \item l'interfaccia web SWISH,
    \item l'interprete prolog,
    \item l'interprete R ed Rserve,
    \item ed infine tutte le dipendenze necessarie di prolog ed R.
\end{itemize}

Poich\'e ogni distribuzione ha il propro metodo per gestire i pacchetti \'e 
necessario creare pacchetti diversi per ognuna. Per fare questo si sono 
separate le parti in comune e quelle specifiche attraverso dei \emph{makefile}
e degli script che costruiscono tali pacchetti. Con un singolo comando \'e 
infatti possibile compilare tutti i pacchetti per una distribuzione.

%%%%
%%%%
%%%%
%%%%


% Appendici.
\appendix
\chapter{qvm} \label{app:qvm}

    \begin{code}
        \caption{Codice sorgente di qvm}
        \bashcodefile{qvm}
    \end{code}

    \newpage

    \begin{code}
        \caption{File di configurazione di qvm}
        \bashcodefile{configvmrc}
    \end{code}


%%%%
%%%%
%%%%
%%%%


\chapter{Rserve sandbox} \label{app:rserve-sandbox}
    \begin{code}
        \caption{File di configurazione di Rserve}
        \bashcodefile{Rserv.conf}
    \end{code}

\chapter{cplint\_r} \label{app:cplint-r}
    \begin{code}
        \caption{Struttura dei predicati dell'interfaccia di cplint\_r}
        \begin{prologcode*}{}
<predicato_interfaccia_r>(input):-
    load_r_libraries,
    <operations on the input>,
    geom_<something>(<new input, possibly lists>),
    finalize_r_graph.
        \end{prologcode*}
    \end{code}

    \begin{code}
        \caption{Predicati per il disegno dei grafici di cplint\_r}
        \begin{prologcode*}{}
geom_<something>(<Lists and/or other input>) :-
    <handle lists>,
    <create one or more R data frame with the lists data>,
    <rename data frame colnames to avoid using default ones>,
    <- ggplot <something>
        \end{prologcode*}
    \end{code}

    \begin{code}
        \caption{La libreria cplint\_r}
        \prologcodefile{cplint_r.pl}
    \end{code}


%%%%
%%%%
%%%%
%%%%


\bibliographystyle{plain}
% file names without the extension, comma separated.
\bibliography{ref}

\end{document}
