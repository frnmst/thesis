% tesi.tex
%
% thesis (c) by Franco Masotti <franco.masotti@student.unife.it>
%
% thesis is licensed under a
% Creative Commons Attribution-ShareAlike 4.0 International License.
%
% You should have received a copy of the license along with this
% work. If not, see <http://creativecommons.org/licenses/by-sa/4.0/>.
%

\documentclass[10pt,titlepage,twoside,a4paper]{report}
\usepackage[margin=1in,a4paper]{geometry}
\usepackage[italian]{babel}
\usepackage{lmodern}
\usepackage[utf8]{inputenc}
\usepackage{graphics,url,amsfonts,epsfig,hyperref,float,listings}
\usepackage{caption}
\usepackage{minted}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{tikz}
\usepackage{csquotes}
\renewcommand{\mkbegdispquote}[2]{\itshape}
\usepackage{setspace}
    \doublespacing
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[listing]{justification=centering,format=listing,labelfont=white,textfont=white}
\DeclareCaptionFormat{figure}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[figure]{justification=centering,format=listing,labelfont=white,textfont=white}

\newenvironment{code}{\singlespacing\captionsetup{type=listing}}{}

% Manually change the language otherwise it does not work.
\renewcommand{\listingscaption}{Listato}
\renewcommand{\listoflistingscaption}{Elenco dei listati}

%%%%%% Enable to debug
%\usepackage{showframe}

\definecolor{bg}{rgb}{0.95,0.95,0.95}

% Global minted options.
\usemintedstyle{tango}
% Verbatim imput
\newminted{text}{fontsize=\footnotesize,frame=single,framesep=10pt,breaklines,bgcolor=bg,linenos=true}
\newminted{prolog}{fontsize=\footnotesize,frame=single,framesep=10pt,breaklines,bgcolor=bg,linenos=true}
\newminted{r}{fontsize=\footnotesize,frame=single,framesep=10pt,breaklines,bgcolor=bg,linenos=true}
% Inputfiles
\newmintedfile[bashcodefile]{bash}{fontsize=\footnotesize,frame=single,framesep=10pt,breaklines,bgcolor=bg,linenos=true}
\newmintedfile[prologcodefile]{prolog}{fontsize=\footnotesize,frame=single,framesep=10pt,breaklines,bgcolor=bg,linenos=true}


%%%%
%%%%
%%%%
%%%%


\title{Integrazione di una applicazione web con strumenti per la statistica}
%\title{\textsc{Integrazione di una applicazione web con strumenti per la statistica}}
\author{Franco Masotti}

\begin{document}
\pagenumbering{roman}

\maketitle
\newpage
\tableofcontents
\newpage
\listoffigures
\newpage
%\listoftables
%\newpage
\listoflistings
\cleardoublepage

\pagenumbering{arabic}


%%%%
%%%%
%%%%
%%%%


\chapter{Introduzione} \label{introduzione}

TODO

\chapter{Specifiche del problema} \label{ch:specifiche-del-problema}
    \section{Componenti software}
Per spiegare il problema è necessario introdurre i software principali che si 
sono utilizzati.

La piattaforma \emph{SWISH}\cite{SWISH} viene usata per la programmazione 
logica attraverso un qualunque web browser dotato di \emph{Javascript}. Questa 
è collegata direttamente all'interprete SWI Prolog.

\emph{Cplint on SWISH} è una versione modificata di SWISH che include la 
libreria \emph{cplint}, la quale permette di formulare inferenze e 
compiere processi di apprendimento\cite{cplint}.

\emph{R} è un ambiente software dedicato alla statistica e 
alla rappresentazione grafica di dati\cite{r}.

\emph{SWI Prolog} è un interprete per la programmazione 
logica\cite{swiprolog}, come suggersice il nome\cite{prolog}.

    \section{Obbiettivi}
L'obbiettivo di questa tesi è quello di illustrare come 
includere l'accesso ad R da parte di Cplint on SWISH, 
oltre che di descrivere i predicati Prolog che disegnano 
grafici standard per Cplint. Si spiegherà infine come si è 
semplificata l'installazione di questo ambiente software.

        \subsection{Accesso ad R da Cplint on SWISH}
Nativamente Prolog non è in grado di accedere all'interprete R. Esistono 
tuttavia delle librerie che permettono di collegarsi all'interprete R
attraverso un \emph{socket} fornito da R stesso. Poiché stiamo utilizzando  
un \emph{server web}, per avere meno problemi di sicurezza, quali ad esempio 
\emph{privilege escalation}, il collegamento tra R e Prolog non può essere 
diretto ma deve passare per un ambiente virtuale isolato chiamato Docker. 
Tutto questo però complica notevolmente l'installazione.

        \subsection{Funzioni grafiche standardizzate}
Esitino funzioni grafiche che sono alternative a quelle fornite dalla libreria 
c3js ed utilizzano invece un pacchetto R chiamato \emph{ggplot2}. Questo 
permette di disegnare gafici standard permettendo all'utente di 
stabilire soltanto quali sono i dati, ed occupandosi della parte grafica. 
I plot sono definiti usando la cosiddetta \emph{grammatica dei 
grafici}, cioè la divisione per contesti dei vari aspetti di un grafico come 
per esempio la geometria, la scala, la rappresentazione estetica, ecc... 
\cite{grammarOfGraphics} 
\cite{ggplot2}

\begin{displayquote}
ggplot2 is a plotting system for R, based on the grammar of graphics, which 
tries to take the good parts of base and lattice graphics and none of the bad 
parts. It takes care of many of the fiddly details that make plotting a hassle 
(like drawing legends) as well as providing a powerful model of graphics that 
makes it easy to produce complex multi-layered graphics.
\end{displayquote}

        \subsection{Semplificazione dell'installazione}
Per semplificare l'installazione e per renderla uniforme a quella di qualunque 
altro programma si sono creati alcuni \emph{pacchetti software} sia per 
le interfaccie web, sia per gli altri programmi descritti nelle sezioni 
precedenti.


%%%%
%%%%
%%%%
%%%%


\chapter{Architettura}
TODO
Detailed description of
    \section{SWISH}
    \section{Cplint on SWISH con supporto R}
    \section{Installazione}
        \subsection{Installazione manuale}
L'installazione manuale consiste in vari passaggi:
\begin{itemize}
    \item nel cercare tutte le dipendenze software
    \item come si installano
    \item e quali altre azioni sono necessarie
\end{itemize}
    Vedere https://frnmst.github.io/swish-installer/swish-installer.html\#Rserve-sandbox-1
        \subsection{Installazione automatica}


%%%%
%%%%
%%%%
%%%%


\chapter{Strumenti}

%%%%
%%%%

    \section{Docker}
\emph{Docker} è un implementazione di una virtualizzazione a livello di sistema 
operativo, cioé permette l'esistenza di molteplici istanze 
di ambienti isolati basate su utenti separati. Con Docker in particolare, 
questi ambienti possono essere eseguiti su qualunque macchina in modo 
indipendente dalla configurazione del sistema operativo, a patto che i 
kernel virtualizzato sia dello stesso tipo di quello ospite.. check this.... In 
questo modo il software che è eseguito al loro interno è garantito funzionare 
in modo affidabile e come lo sviluppatore aveva inteso che funzionasse.
\cite{operatingSystemLevelVirtualization} \cite{docker}

        \subsection{Immagini}
Attraverso un documento di testo chiamato \emph{Dockerfile}, Docker viene 
istruito nel costruire un'\emph{immagine} che comprende un'insieme di 
programmi, file, utenti e tutto ciò che è necessario allo svolgimento di
un specifico compito. Le istruzoni nel documento di testo sono nella forma
\mintinline{bash}{ISTRUZIONE_DOCKER argomento}. Per aggiungere utenti, 
gruppi ed altre operazioni viene usata l'istruzione \textbf{RUN} seguita dal 
percorso di una shell disponibile e infine dal comando che deve essere eseguito. Per 
semplicità si può anche omettere la shell ne verrà usata una di default. Per 
esempio \\
\mintinline{shell}{RUN /bin/bash -c groupadd -g newgroupid groupname}

Altri comandi importanti sono:
\begin{itemize}
    \item \textbf{CMD}, che stabilisce l'istruzione che deve essere 
eseguita ad ogni avvio dell'immagine
    \item \textbf{ENV}, che imposta variabili d'ambiente
    \item \textbf{USER}, che effettua un cambio di utente per tutti i comandi che lo seguono
    \item \textbf{WORKDIR}, che cambia directory al volo
    \item \textbf{ADD}, che copia file nell'immagine
\end{itemize}

Dopo aver costruito l'immagine con \mintinline{bash}{$ docker build <nome 
immagine> .},
la si può eseguire con \mintinline{bash}{$ docker run <nome immagine>}.
L'istanza di un immagine è chiamata \emph{container} 
\cite{DockerfileReference}.

Utilizzando i Dockerfile la comunità di utilizzatori di Docker continua a 
creare e a distribuire nuove immagini precomilate ognuna con un particolare 
utilizzo.
Il vantaggio di questo metodo è che l'utente finale è in grado di utilizzare 
subito l'immagine, senza che possano sorgere problemi nella fase di build. Lo 
svantaggio tuttavia è che l'immagine può  essere anche molto grande 
(nell'ordine del Gigabyte) e quindi difficile da distribuire con i mezzi di 
rete più noti.

%%%%
%%%%

    \section{R}
R è un ambiente software per il calcolo statistico e la 
visuallizzazione grafica. Con il termine R si definisce l'interprete
dei comandi mentre con S il linguaggio di programmazione. R comprende anche un 
gestore di pacchetti attraverso il quale si possono installare facilmente
funzioni utili non comprese in R stesso.

        \subsection{Comandi}
L'assegnazione di un valore di una variabile avviene con il 
comando \mint{r}|<- c(<qualcosa>)|, dove "c" serve a concatenare valori.
\cite{rAssignmentOperator}

        \subsection{Oggetti}
Come molti linguaggi di programmazione, R mette a disposizione strutture dati 
chiamate oggetti. Questi possono essere variabili, array di numeri, stringhe, 
funzioni e qualunque cosa derivata da queste.
\cite{rObject}

        \subsection{Le liste}
In R le liste sono una collezione ordinata di oggetti, qui chiamati anche 
componenti, che possono essere di tipo diverso tra di loro. Con queste liste si 
ha la possibilità di accedere direttamente alle componenti sia attraverso il 
principio dell'indicizzazione, sia attraverso l'uso della notazione 
\mintinline{r}{lista$componente}.
\cite{rList}

        \subsection{Dalle liste ai data frame}
Alcune funzioni disponibili nella libreria \emph{r\_swish} permettono il 
passaggio di valori tra Prolog ed R attraverso i \emph{data frame}. Questi 
sono un tipo particolare di \emph{oggetti} che permettono 
di organizzare i dati sotto forma matriciale. ...
I data frame in R sono definiti come specializzazione della classe lista.
Rispetto ad una lista, infatti, esistono delle restrizioni...

I data frame si rivelano anche efficienti per R stesso.... cite ...
\cite{rDataFrame}

%%%%
%%%%

    \section{rserve\_client}
La libreria rserve\_client permette di utilizzare i comandi 
disponibili dell'interprete R direttamente da SWISH poiché il supporto per R 
all'interno di SWISH è ancora di recente implementazione. 
Di solito quindi la parte computazionale viene affidata all'interprete Prolog, 
mentre la parte grafica viene gestita dalla libreria c3js. Con questa libreria
invece sia la parte grafica sia quella computazionale sono eseguite
da R e visualizzate con SWISH.

        \subsection{Funzionamento interno}
L'utilizzo di R rispetto a Javascript comporta due 
differenze: in alcuni casi si può ottenere una maggiore 
velocità\cite{rFaster}:
\begin{displayquote}
[..] It turns out R does the job faster on a large number of integers
than Prolog.  Why?  Once in R, the array is a simple C array of integers,
causing a blindly fast addition.  The Prolog counterpart adds the numbers
one-by-one and does rigid overflow checking and handling.
\end{displayquote}
 
Inoltre, la computazione per il disegno dei grafici è fatta sul server e non 
sul computer locale attraverso il browser.
 
e la possibilità di usare i sistemi di plot di R, come per esempio ggplot2 
che si rivelano più precisi ... cite ... ...

Nel caso presente tutte le chiamate fatte da Prolog a R vengono passtate 
attraverso un socket UNIX creato dal programma \emph{Rserve}\cite{rserve}. 
Questo è stato configurato opportunamente per quanto riguarda la sicurezza 
in quanto viene eseguito all'interno di Docker e senza che venga esposta una 
connessione di rete.

\begin{figure}[H]
\centering
\caption{Schema funzionamento}
\begin{tikzpicture}
    \draw[thick] 
(-5,5) -- node[align=left, below]{Sistema}
(5,5) -- 
(5,-5) -- 
(-5,-5) --
cycle;
    \draw[thick]
(-4,3) -- node[align=left, below]{Istanza Docker}
(1,3) --
(1,-4) --
(-4, -4) --
cycle;
    \draw[thick]
(-2,-1) -- node[align=left, below]{Socket \\ UNIX \\ Rserve}
(0,-1) --
(0,-3) --
(-2, -3) --
cycle;
    \draw[thick]
(2,-1) -- node[align=left, below]{Processo \\ SWISH}
(4,-1) --
(4,-3) --
(2, -3) --
cycle;
    \draw[thick, red, ->]
(0,-1.5) --
(2,-1.5);
    \draw[thick, red, ->]
(2,-2.5) --
(0,-2.5);
\end{tikzpicture}
\end{figure}

\begin{code}
    \caption{File di configurazione di Rserve}
    \bashcodefile{Rserv.conf}
\end{code}

\subsection{Scambiare i dati fra R e Prolog}
SWI Prolog è accessibile da shell con il comando \texttt{swipl}.

Grazie ad una libreria di SWI Prolog chiamata 
\emph{rserve\_client}\cite{rserveclient} 
è possibile usare direttamente comandi di R facendo minime modifiche 
rispetto allo stesso codice usato nell'interprete R.

Esistono due modalità per usare i comandi di R all'interno di SWI Prolog:
\begin{itemize}
    \item come Prolog term, usando l'operatore \texttt{<-} seguito dal comando R,
    \item oppure con una notazione chiamata \emph{quasi-quotation}
\end{itemize}
La documentazione di SWISH contiene un esempio per entrambi i 
casi\cite{rprolognotations}:
\begin{displayquote}
[..] We first give the example using an R quasi quotation, followed by 
using a Prolog term.  Note that

  - Quasi quotations can be used to copy/paste R code into your Prolog
    program without changing it (except when it contains \texttt{|{\textbraceright}}).

  - Prolog code may need minor modifications.  In the example, \texttt{I(.5)}
    must be changed to \texttt{'I'(0.5)} because Prolog floats cannot start with
    a \texttt{.} and functors (used as function symbols) cannot start with a
    capital.  The Prolog approach however

    - Is better portable.

    - Profits from Prolog syntax checking.

    - Makes it easier to compose R expressions from smaller elements.
\end{displayquote}

\begin{code}
    \caption{Esempi notazioni R in SWI Prolog}
    \begin{prologcode*}{}
<- qplot(mpg, data=mtcars, geom="density", fill=gear, alpha='I'(0.5), main="Distribution of Gas Milage", xlab="Miles Per Gallon", ylab="Density").

<- {|r||qplot(mpg, data=mtcars, geom="density", fill=gear, alpha=I(.5), main="Distribution of Gas Milage", xlab="Miles Per Gallon", ylab="Density")|}.
    \end{prologcode*}
\end{code}

Come si vede nel primo caso è necessario fare qualche piccola modifica 
rispetto all'originale R. Nel secondo caso invece è possibile gestire alcuni 
casi particolari che genererebbero errori oppure che non sarebbe possibile 
possibile trasformare nel primo caso.

Nella scrittura di cplint\_r si è anche trovato un caso non segnalato nella 
documentazione in cui non è possibile trasformare un comando con la 
notazione abbreviata, probabilmente per l'uso di istruzioni condizionali:

\begin{code}
    \caption{Esempio di quasi quotation tratto da cplint\_r}
    \begin{rcode*}{}
{|r||xbreakS <- if(max(df$probabilities) > scalingthresholD) element_blank() else scale_y_continuous(breaks=seq(0,max(df$probabilities),1))|},
    \end{rcode*}
\end{code}

Un'altro fattore importante è che ogni comando R inviato attraverso questo 
sistema viene eseguito in un ambiente proprio. Le variabili devono essere 
salvate in Prolog se sono usate successivamente.

%%%%
%%%%

\section{QVM}
Per completare tutto il lavoro e testare le modifiche sui programmi man 
mano, è stato necessario installare l'intera piattaforma sul computer. 
Questo è stato possibile attraverso l'utilizzo di macchine virtuali 
per ragioni di comodità.

\subsection{Macchine virtuali}
Per agevolare l'installazione ed il mantenimento della piattaforma web su una 
istanza locale si sono utilizzate macchine virtuali con immagini di 
distribuzioni GNU/Linux diverse quali: Antergos, Parabola GNU/Linux-libre, 
Debian e Trisquel.

\subsubsection{Qemu Virtual Machine}
Utilizzando il programma \emph{QEMU}\cite{qemu} si è potuto scrivere uno 
programma per 
shell, \emph{qvm}, in modo da gestire facilmente tutti i casi d'uso che si 
sono presentati\cite{qvm}. Questo si è rivelato molto utile per esempio per 
gestire i backup dei dischi rigidi virtuali. Infatti per testare nuovi 
pacchetti e programmi è consigliabile partire sempre da un sistema pulito
per evitare che precedenti installazioni possano alterare il funzionamento.
Con qvm sono infatti sufficienti un paio di comandi per ripristinare il 
backup e corregere l'errore.

Lo script dà anche la possibilità di condividere file fra la macchina host 
e guest attraverso una semplice directory.

poiché l'interfaccia web di SWISH è accessibile attraverso un \emph{port} 
ben definito (di default \emph{3050}), si è fatto in modo che tale port 
fosse accessibile dalla macchina host con il port \emph{5555}. Oltre a questo 
è anche possibile l'accesso attraverso attraverso \emph{Secure 
Shell} (\emph{SSH}). Mettendo insieme queste due caratteristiche non è 
neccessario avviare l'interfaccia grafica.

Di seguito è riportata l'opzione di aiuto, mentre lo script si trova 
nell'appendice~\ref{app:qvm}.

\begin{code}
    \caption{Pagina di aiuto di qvm}
    \begin{textcode*}{}
Usage: qvm [OPTION]
Trivial management of 64 bit virtual machines with qemu.

Options:
    -a, --attach                connect via SSH
    -b, --backup                backup vhd
    -c, --create                create new vhd
    -d, --delete                delete vhd backup
        --delete-orig           delete original vhd
    -h, --help                  print this help
    -i, --install               install img on vhd
    -n, --run-nox               run vm without opening a graphical window
                                (useful for background jobs like SSH)
        --run-nox-orig          run-orig and run-nox combined
    -s, --mkdir-shared          create shared directory
    -x, --run                   run vm
        --run-orig              run from original vhd


Only a single option is accepted.
By default, the backup vhd is run.

CC0
Written in 2016 by Franco Masotti/frnmst <franco.masotti@student.unife.it>
    \end{textcode*}
\end{code}

\subsubsection{Installazione e avvio di una nuova macchina virtuale con qvm}
La prima cosa da compiere è quella di ottenere l'immagine \emph{ISO} della 
distribuzione da installare.

Successivamente si deve configurare il file \texttt{configvmrc} inserendo il 
nome del file ISO.

Poi è necessario eseguire \mint{bash}|$ ./qvm -c| per creare un nuovo 
disco rigido virtuale, poi \mint{bash}|$ ./qvm -i| per l'installazione.

Una volta terminata l'installazione si può aggiungere SSH sulla macchina 
guest oltre che aggiungere la seguente riga nel file \texttt{/etc/fstab} della 
macchina virtuale in modo da aggiungere la directory condivisa:

\begin{code}
   \caption{Comando fstab}
    \begin{textcode*}{}
host_share /home/<shared_directory_path> 9p noauto,x-systemd.automount,trans=virtio,version=9p2000.L 0 0
    \end{textcode*}
\end{code}

Ora si può creare un backup dell'hard disk virtuale con \mint{bash}|$ ./qvm 
-b| che nel caso fosse necessario rimuoverlo basterà fare \mint{bash}|$ ./qvm 
-d|

Successivamente si avvia la macchina virtuale con \mint{bash}|$ ./qvm -x| 
oppure con \mint{bash}|$./qvm -n| rispettivamente a seconda che si utilizzi o 
non si utilizzi l'interfaccia grafica sulla macchina guest.

Infine, per collegarsi via SSH: \mint{bash}|$ ./qvm -a|

\begin{figure}[H]
\centering
\caption{Schema della relazione tra i port della macchina host e guest}
\begin{tikzpicture}
    \draw[thick] 
(-4,4) --
(4,4) --
(4,-4) -- node[align=left, above]{Host \\ SWISH: 5555 \\ SSH:2222}
(-4,-4) --
cycle;
    \draw[thick]
(-2,2) -- 
(2,2) --
(2,-2) -- node[align=left, above]{Guest \\ SWISH: 3050 \\ SSH: 22}
(-2,-2) --
cycle;
    \draw[thick, red, <->]
(0,-2.0) --
(0,-3.0);
    \draw[thick, red, <->]
(1,-2.0) --
(1,-3.0);
\end{tikzpicture}
\end{figure}

\begin{code}
    \caption{Codice sorgente di qvm}
    \bashcodefile{qvm}
\end{code}

\newpage

\begin{code}
    \caption{File di configurazione di qvm}
    \bashcodefile{configvmrc}
\end{code}


%%%%
%%%%
%%%%
%%%%


\chapter{Pacchetti per le varie distribuzioni} 
\label{ch:pacchetti-per-le-varie-distribuzioni}
Per affrontare il problema dell'installazione di tutti i componenti di cui si 
è parlato fino ad ora, si è resa quindi necessaria la creazione di vari 
pacchetti software per:
\begin{itemize}
    \item l'interfaccia web SWISH,
    \item il daemon Rserve,
    \item ed infine tutte le dipendenze necessarie di Prolog ed R.
\end{itemize}

Ora verrà spiegata la terminologia ed il procedimento.

%%%%
%%%%

\section{Pacchetto e gestore di pacchetti} \label{pacchetto-e-gestore-di-pacchetti}
Un pacchetto software è una raccolta di istruzioni che permettono di 
installare un programma in modo uniforme rispetto a tutti gli altri programmi 
di un sistema. Questo è possibile grazie ad un \emph{gestore di 
pacchetti}.

Questi gestori hanno contribuito al successo delle distribuzioni GNU/Linux (ed 
altre, per esempio BSD) perché consentono a chiunque di installare un 
programma senza aver conoscenza di metodi di compilazione oltre a rendere 
l'installazione più veloce e meno prona a generare errori.

In generale, per costruire un pacchetto software è necessario delineare prima 
alcune caratteristiche:
\begin{itemize}
    \item Quali sono le dipendenze e come si relazionano tra di loro.
    \item in che modo è necessario adattare il pacchetto in modo che funzioni 
          con la specifica distribuzione; cioè quali \emph{helper} devono 
essere creati e come.
    \item Il software funziona così com'è oppure bisogna creare utenti, 
file, etc...
\end{itemize}

poiché l'obbiettivo è stato quello di creare pacchetti per varie 
distribuzioni è stato necessario un'ulteriore passaggio: separare le parti in 
comune che esistono tra le distribuzioni con le loro parti specifiche. In 
questo caso le parti in comune comprendono:
\begin{itemize}
    \item Gli script per avviare e fermare i daemon.
    \item Le istruzioni per installare i pacchetti Prolog.
    \item Le configurazioni per i sistemi di init (nel caso in questiojne è 
presente solo \emph{Systemd} ma si potrebbe generalizzare per qualunque 
sistema).
    \item Le azioni da fare prima, durante e dopo l'intallazione e la rimozione 
del pacchetto. Queste vengono date in forma generica e quindi vanno adattate 
con qualche modifica al caso in uso.
\end{itemize}

Una volta definite le caratteritiche di base, si è passato alla scrittura dei
pacchetti veri e propri. Si è deciso di iniziare con la
distribuzione \emph{Arch Linux} per poi passare a \emph{Debian}.

%%%%
%%%%

\section{Arch Linux}
\emph{Arch Linux} è una distribuzione \emph{bleeding edge} e \emph{rolling 
release}. Questo significa che i pacchetti sono sempre all'ultima versione 
stabile e che la distribuzione non viene rilasciata come versione stabile, 
cosa che accade per la maggior parte delle distribuzioni. Tutto questo è 
speigato nella wiki ufficiale\cite{archLinux}:
\begin{displayquote}
Arch Linux è una distribuzione indipendente sviluppata per i686/x86-64, 
abbastanza versatile ed adatta ad ogni ruolo. Il suo sviluppo si concentra 
sulla semplicità, il minimalismo e l'eleganza del codice. Arch è installato 
come sistema di base minimale (configurato dall'utente) sul quale viene 
costruito il proprio ambiente ideale, installando solo ciò che è necessario 
in base alle proprie necessità. Le GUI delle utility di configurazione non 
sono fornite ufficialmente e la maggior parte della configurazione del sistema viene 
eseguita dalla Shell e da un editor di testo. Basata sul modello 
rolling-release, Arch si sforza di rimanere all'avanguardia, e di solito offre 
le ultime versioni stabili della maggior parte dei software.
\end{displayquote}
Lo svantaggio principale di questo sistema è che il software distribuito 
può non esssere sempre stabile in quanto non testato pienamente.

\subsection{Struttura}
Arch Linux adotta un sistema di pacchettizzazione relativamente semplice 
che è simile al sistema \emph{ports} di alcuni sistemi 
BSD\cite{portsLikeSystem}:
\begin{displayquote}
Ports è il sistema usato da FreeBSD per l'automazione della generazione di 
pacchetti a partire dal codice sorgente. Il sistema usa un port per scaricare, 
scompattare, patchare, compilare e installare il software desiderato. Un port 
è solo una piccola directory nel computer dell'utente, chiamata come il 
corrispondente software che vi verrà installato, che contiene un po' di file 
con le istruzioni per scaricare ed installare il pacchetto dai sorgenti. Questo 
rende possibile la generazione del pacchetto con un semplice \texttt{make} o 
\texttt{make install clean} all'interno della directory port.
\end{displayquote}

Nei casi più semplici è sufficiente definire un file chiamato 
\texttt{PKGBUILD}. Questo contiene le istruzioni solo per fare il build del 
pacchetto, di come copiare il contenuto nel \emph{filesystem} e di come 
recuperare il software. Nel nostro caso è stato però necessario aggiungere
il file \texttt{.install}. Questo si occupa degli \emph{hook}, cioè delle 
azioni, per l'installazione e la rimozione. Infine sono stati aggiunti i file 
per \emph{Systemd} e gli script per avviare i daemon. Tutto questo è stato 
ripetuto per ogni pacchetto.

%%%%
%%%%

\section{Debian e Ubuntu}
Debian GNU/Linux è tra le prime distribuzioni mai 
create\cite{debianFirstDistro} ed 
è tra le più stabili considerate oggi... cite ...
 
\cite{debian}
\begin{displayquote}
Il Progetto Debian è una associazione di persone che ha come scopo comune la 
creazione di un sistema operativo libero. Il sistema operativo che abbiamo 
creato si chiama Debian.

[...]

Certo, la cosa che la gente vuole è il software applicativo. Strumenti che 
permettano loro di ottenere che sia fatto ciò che vogliono, dallo scrivere 
documenti a gestire il lavoro ad eseguire giochi a scrivere altro software. 
Debian si presenta con più di 43000 pacchetti (software precompilato messo 
insieme in un formato adatto ad essere installato in maniera semplice sulla 
propria macchina), un gestore di pacchetti (APT) e altri programmi di utilità 
che permettono di gestire migliaia di pacchetti su migliaia di computer con la 
stessa semplicità con cui si installa un'applicazione. Tutto completamente 
free. 
\end{displayquote}

Ubuntu è invece meno stabile, tuttavia ha a
disposizione pacchetti più recenti.

... Ubuntu description...

\subsection{Struttura}
Il procedimento descritto nella sezione~\ref{pacchetto-e-gestore-di-pacchetti}
si è ripetuto anche per \emph{Debian} e \emph{Ubuntu}. Una delle più 
importanti differenze rispetto ad Arch è che in questo caso è necessario 
avere già scaricato il software prima di fare il build del pacchetto.

Deve essere creata una la directory \texttt{debian} nella directory principale 
del codice sorgente. All'interno di questa verranno posti tutti file 
necessari come \texttt{rules}, \texttt{control} e molti altri obbligatori e 
facoltativi. Il file \texttt{rules} è un makefile che contiene istruzioni per 
quanto riguarda la compilazione del pacchetto. Si può per esempio specificare 
di incudere i file per Systemd poiché non viene fatto di default. Il file 
\texttt{control} invece contiene informazioni sulle dipendenze, maintainer, 
descrizioni, etc... 

.. Brief APT + PPA descriptiion ...

%%%%
%%%%

\section{Descrizione dei pacchetti e delle funzionalità}
Come accennato all'inizio del capitolo~\ref{ch:pacchetti-per-le-varie-distribuzioni}
i pacchetti software creati comprendono SWISH, l'ambiente R, e tutto il 
necessario.

Per Arch Linux sono stati scritti il maggior numero di pacchetti:
\begin{itemize}
    \item \texttt{swish}: installa la versione ufficiale di SWISH, che non 
contiene modifiche
    \item \texttt{swish-cplint}: è una versione modificata che comprende 
cplint e cplint\_r
    \item \texttt{rserve-sandbox-docker}: installa l'ambiente R che permette di 
creare il socket gestito da Rserve. Questa è una dipendenza fondamentale di 
\texttt{swish-cplint}
    \item \texttt{swish-cplint-bin} e \texttt{rserve-sandbox-docker-bin}: 
questi sono analoghi alle versioni non \emph{bin} per quanto riguarda le 
funzionalità. Quello che cambia è che i componenti più importanti sono 
precompilati. Questo è stat o necessario poiché sia \texttt{swish-cplint}, 
sia \texttt{rserve-sandbox-docker} sono basati su componenti che devono essere 
scaricati da Internet nel momento della creazione dei pacchetti. Nel caso 
qualche componente non fosse raggiungibile, l'installazione o qualche 
funzionalità fallirebbe. In particolare, \texttt{rserve-sandbox-docker-bin} 
fa riferimento ad un immagine Docker precompilata e poi resa disponibile 
attraverso un repository git. \texttt{swish-cplint-bin} invece contiene tante 
dipendenze Javascript\cite{javascriptDepsSWISH} Queste sono sparse su molti 
repository diversi. Come alternativa, gli sviluppatori 
di SWISH hanno messo a disposizione un file \emph{zip}\cite{SWISHwebDepsZip} 
con tutti gli strumenti precompilati. è sufficiente quindi usare questi ed 
è proprio quello che fa \texttt{swish-cplint-bin}:
\begin{displayquote}
[...]
As installing node and bower is not a pleasure on all operating systems,
you can also download the dependencies as a single zip file [...]
Unpack the zip file, maintaining the directory structure, from the swish
root directory to create the directory web/bower\_components.
\end{displayquote}
\end{itemize}

Per Debian/Ubuntu, viste alcune difficoltà spiegate nella 
sezione~\ref{sec:problemi}, si è provveduto soltanto a scrivere 
\texttt{rserve-sandbox-docker} e \texttt{swish-cplint}.

%%%%
%%%%

\section{Build e installazione dei pacchetti}
Per gestire questa situazione complessa, per ogni distribuzione esiste un 
\texttt{Makefile} ed uno script shell chiamato \texttt{build\_pkg.sh}. 
Quest'ultimo viene chiamato dal \texttt{Makefile} con parameteri diversi volta 
per volta. Entrambi si occupano di costruire automaticamente i pacchetti senza 
che l'utente abbia alcuna conoscenza dei meccanismi interni. è sufficiente 
infatti eseguire \mint{bash}|$ make| per costruire tutti i pacchetti 
disponibili, mentre l'installazione avviene con \mint{bash}|$ makepkg -sri|
per Arch e \mint{bash}|$ debuild -us -uc && dpkg -i| per Debian.

\section{Distribuzione dei pacchetti}
Alcune distribuzioni dispongono di repository per gli utenti. In questo modo 
chiunque può mettere a disposizione pubblicamente i propri pacchetti.

Arch Linux per esempio ha l'\emph{AUR}\cite{aur}
\begin{displayquote}
Arch User Repository (AUR) è un repository sostenuto dalla comunità per utenti 
Arch. Contiene le descrizioni dei pacchetti (i PKGBUILD) che ti permettono di 
compilare i sorgenti grazie al comando makepkg e quindi installarli con pacman. 
AUR è stato creato per creare e scambiare pacchetti tra la comunità e per 
aiutarne lo sviluppo, inclusi i pacchetti del repository community. Questo 
documento spiega come accedere ed installare i pacchetti presenti in AUR. 
\end{displayquote}

%%%%
%%%%

\section{Problemi} \label{sec:problemi}
\subsection{Debian}
Un'altro problema è che Debian ha a disposizione software che non è
abbastanza recente per il caso in questione. Questo è vero sia che si 
utilizzi la versione \emph{stable} sia \emph{unstable}. Per quanto riguarda 
SWISH è infatti necessario avere sempre l'ultima versione di SWI Prolog,
come è descritto nella documentazione ufficiale \cite{lastestSWIProlog}:
\begin{displayquote}
Install the latest  SWI Prolog development version. As SWISH is very much in 
flux and depends on the recent SWI-Prolog pengines and sandboxing libraries, 
it is quite common that you need the nightly build (Windows) or build the 
system from the current git development repository swipl-devel.git.
\end{displayquote}

Questo sarebbe possibile  soltanto ricompilando il software. Ma anche questo 
non è fattibile poiché mancano ancora alcune librerie fondamentali. L'unico 
software che sembra funzionare correttamente è Rserve sandbox.

Viste queste difficoltà si è deciso utilizzare una distribuzione derivata 
da Ubuntu, chiamata \emph{Trisquel}. In questo caso, abilitando i PPA di SWI 
Prolog\cite{SWIPrologPPA}, si è riuscito ad installare tutto con minime 
difficoltà. Tuttavia è presente qualche problema che inibisce l'accesso ad 
Rserve da SWISH.

\subsection{Alternative}
... Tutto il sistema spiegato fino ad ora comporta il dover tener traccia di 
molti fattori all'aumentare del numero di distribuzioni supportate. Nell'ultimo 
periodo stanno emergendo gestori di pacchetti che sono indipendenti dalla 
distribuzione in uso e che dovrebbero semplificare anche la gestione delle 
dipendenze (OBS, Flatpack, Snap) ...


%%%%
%%%%
%%%%
%%%%


\chapter{Predicati per disegnare grafici in Cplint on SWISH} 
\label{predicati-per-disegnare-grafici-in-cplint-on-swish}
\emph{cplint\_r} è una libreria per SWI Prolog che fornisce un'interfaccia 
fra l'interprete Prolog ed R, in modo da poter graficare i risultati generati 
dalla libreria cplint. Questo significa che cplint\_r si occupa esclusivamente 
del disegno dei grafici. cplint\_r usa estensivamente la libreria ggplot2 per 
graficare. Questa fornisce risultati esteticamente migliori rispetto a quella 
fornita di default.

\section{Descrizione dei tipi di predicati}
cplint\_r è in grado di disegnare:
\begin{itemize}
    \item istogrammi,
    \item grafici a barre,
    \item e curve che rappresentano funzioni di densità.
\end{itemize}

\section{Struttura}
cplint\_r è composta da tre diversi tipi di predicati:
\begin{enumerate}
    \item I predicati che espongono un'interfaccia. Questi chiamano alcuni 
          predicati di cplint per quanto riguarda il calcolo dei risultati. 
          Hanno gli stessi nomi di cplint con, in aggiunta, il suffisso 
          \texttt{\_r}.

        \begin{code}
            \caption{Struttura dei predicati dell'interfaccia di cplint\_r}
            \begin{prologcode*}{}
<predicato_interfaccia_r>(input):-
    load_r_libraries,
    <operations on the input>,
    geom_<something>(<new input, possibly lists>),
    finalize_r_graph.
            \end{prologcode*}
        \end{code}
    \item Le funzioni grafiche invece per prima cosa trasformano i dati in 
          input in data frame leggibili da R, poi viene effettuato il disegno 
          dei grafici. Tutti questi hanno il prefisso \texttt{geom}. Qui viene 
fatto un uso estensivo dei data frame.

    \begin{code}
        \caption{Predicati per il disegno dei grafici di cplint\_r}
        \begin{prologcode*}{}
geom_<something>(<Lists and/or other input>) :-
    <handle lists>,
    <create one or more R data frame with the lists data>,
    <rename data frame colnames to avoid using default ones>,
    <- ggplot <something>
        \end{prologcode*}
    \end{code}
    \item Infine, sono stati scritti alcuni predicati che aiutano a gestire le 
          liste di valori generate dalle funzioni di cplint. Queste liste 
          vengono poi trasformate in data frame in modo che possano 
          essere utilizzati da R. Da notare che questi predicati si trovano 
          all'interno delle funzioni grafiche.
\end{enumerate}

Per ogni insieme di valori si è deciso di usare un data frame diverso. In 
questo modo è stato possibile aggregare più insiemi di valori quando 
necessario. ... example + cite ...

%%%%
%%%%

\section{La libreria come pacchetto}
Come succede con altre librerie SWI Prolog, cplint\_r è distribuita sotto 
forma di \emph{pack}, cioè pacchetto. Esiste infatti un gestore di pacchetti 
in modo che l'installazione di librerie risulti semplice ed uniforme: 
\mint{prolog}|pack_install(cplint_r).|

In questo modo è possibile avere a disposizione la libreria con 
\mint{prolog}|use_module(library(cplint_r)).|

Nel file di configurazione \texttt{pack.pl} che si trova al'interno del pack 
sono elencate tutte le dipendenze, la versione della libreria, descrizioni, 
ed altre informazioni di cplint\_r. Il gestore di pacchetti andrà a leggere 
questo file per installare il tutto in \texttt{\$HOME/lib/pack/..../cplint\_r}

Al momento dell'installazione cplint\_r esegue dei semplici 
test per verificare che la libreria stessa funzioni correttamente.

%%%%
%%%%

\section{Trasformazione degli esempi da c3js ad R} \label{sec:trasformazione-
degli-esempi-da-c3js-ad-r}
Per applicare la nuova libreria cplint\_r a casi reali si sono trasformati 
esempi da c3js ad R.

Dopo aver definito le basi della libreria cplint\_r si è provveduto a 
trasformare qualche esempio più semplice da c3js ad R. Infatti si è 
dovuto cambiare una minima parte del codici, tranne in casi particolari, che 
non hanno permesso di sfruttare completamente la 
libreria cplint\_r. Per queste occasioni si sono dovuti creare predicati 
specifici per risolvere il problema. Si vedano gli esempi.

\section{Differenze rispetto a cplint}
...Esistono tuttavia alcune differenze rispetto a cplint, come ad esempio che 
una parte del lavoro viene fatto gestire da ggplot2 automaticamente ... esempio 
bins histograms ... ... code here ...
...

La libreria cplint delega la parte grafica all'interno di ogni esempio usando 
c3js mentre in cplint\_r è la libreria stessa a gestire tutto (come spiegato 
prima).

\begin{code}
    \caption{La libreria cplint\_r}
    \prologcodefile{cplint_r.pl}
\end{code}


%%%%
%%%%
%%%%
%%%%


\chapter{Esempi}
Di seguito vengono riportati i principali esempi di programmi trasformati dalla 
versione c3js alla versione R.

\section{Utilizzo di cplint\_r}
Utilizzando solo cplint\_r

\section{Casi particolari} \label{sec:case-particolari}
Come detto precedentemente, sono state create alcune funzioni ad-hoc
nei casi in cui non è stato possibile generalizzare.

\subsection{gpr\_R}

\subsection{kalman\_filter\_R} 

\subsection{seven\_scientists\_R}
Il predicato \texttt{geom\_bar/1}  genera un diagramma a barre 
utilizzando alcune funzioni definite in cplint\_r. Poichè abbiamo 7 elementi 
fissi sulle ascisse dobbiamo usare \texttt{numlist(1,7,X)}, una lista da 7 
elementi e \texttt{breaks=seq(0,7,1)} per evidenziare i 7 prunti sul grafico.
Si è inoltre usato \texttt{breaks=seq(0,max(df\$val),2)} per imitare il 
comportamento della versione c3js.


%%%%
%%%%
%%%%
%%%%


\chapter{Conclusioni}

TODO

%%%%
%%%%
%%%%
%%%%


\bibliographystyle{unsrt}
%\bibliographystyle{plain}
% file names without the extension, comma separated.
\bibliography{ref}

\end{document}
